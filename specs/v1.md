# HWInfo TUI v1.0 Specification

## Overview

HWInfo TUI is a command-line terminal visualization tool inspired by [gping](https://github.com/orf/gping) for monitoring real-time hardware sensor data from HWInfo. The application provides a clean, focused interface displaying selected sensors in a single line chart with live statistics above.

## Command Line Interface

### Basic Usage

```bash
hwinfo-tui sensors.csv sensor1 sensor2 [sensor3...]
```

### Examples with Unit Filtering

#### Valid Examples (Single Unit)

```bash
# All temperature sensors - single unit [°C]
hwinfo-tui sensors.csv "Core Temperatures (avg) [°C]" "GPU Temperature [°C]" "CPU Package [°C]"

# All percentage sensors - single unit [%]  
hwinfo-tui sensors.csv "Total CPU Usage [%]" "GPU Core Load [%]" "GPU Memory Usage [%]"
```

#### Valid Examples (Two Units)

```bash
# Temperature and percentage - two units [°C] and [%]
hwinfo-tui sensors.csv "Core Temperatures (avg) [°C]" "Total CPU Usage [%]" "GPU Temperature [°C]"

# Power and temperature - two units [W] and [°C]
hwinfo-tui sensors.csv "CPU Package Power [W]" "CPU Package [°C]" "GPU Power [W]"
```

#### Invalid Examples (Too Many Units)

```bash
# This would exclude the [W] sensors and show warnings
hwinfo-tui sensors.csv "Core Temperatures (avg) [°C]" "Total CPU Usage [%]" "CPU Package Power [W]"
# Output: "Excluded sensor 'CPU Package Power [W]' with unit [W] - chart limited to units [°C] and [%]"

# This would exclude everything after the first two units
hwinfo-tui sensors.csv "GPU Temperature [°C]" "GPU Power [W]" "Total CPU Usage [%]" "Memory Usage [%]"
# Output: "Excluded sensor 'Total CPU Usage [%]' with unit [%] - chart limited to units [°C] and [W]"
# Output: "Excluded sensor 'Memory Usage [%]' with unit [%] - chart limited to units [°C] and [W]"
```

### Arguments

- **CSV File**: Path to HWInfo sensors.csv file (positional argument)
- **Sensor Names**: One or more sensor column names to monitor (variadic positional arguments)
- **Options**:
  - `--refresh-rate FLOAT`: Update frequency in seconds (default: 1.0)
  - `--time-window INTEGER`: History window in seconds (default: 300)
  - `--theme TEXT`: Color theme selection (default/dark/matrix)
  - `--help`: Show help message and usage examples
  - `--version`: Display application version information

### Command-line Framework: Typer

- **Repository**: <https://github.com/fastapi/typer>
- **Purpose**: Modern, fast CLI framework built on Click with excellent type hints support
- **Key Features**:
  - **Type Safety**: Full type hint support with automatic validation
  - **Auto-completion**: Shell completion for bash, zsh, fish, and PowerShell
  - **Rich Help**: Beautiful help messages with colors and formatting
  - **Intuitive API**: Simple decorator-based command definition
  - **Error Handling**: Excellent error messages with suggestions
  - **Integration**: Seamless integration with Rich for enhanced terminal output

## Core Objectives

- **Focused Monitoring**: Display specific user-selected sensors in a single, clear visualization
- **gping-inspired UI**: Clean interface with statistics table above the main chart
- **Real-time Updates**: Continuously monitor CSV file with live chart updates
- **Command-line Driven**: Simple CLI interface for selecting sensors to monitor
- **Performance Insight**: Immediate visibility into selected sensor trends and statistics

## Technical Architecture

### Primary Libraries

#### Plotext (Terminal Plotting)

- **Repository**: <https://github.com/piccolomo/plotext>
- **Purpose**: Advanced ASCII/Unicode chart generation for terminal displays
- **Key Features**:
  - **Multiple Axes Support**: Independent x/y axes (upper/lower x-axis, left/right y-axis) for overlaying different metrics
  - High-resolution terminal plots with Braille Unicode characters
  - Comprehensive chart types: line plots, scatter plots, bar charts, histograms, candlestick charts, matrix plots
  - Time-series visualization with datetime axes and date formatting
  - Real-time streaming data with `clt()` (clear terminal) and `cld()` (clear data) for smooth updates
  - Rich color and marker customization with themes
  - Interactive subplot support for complex dashboard layouts

#### Rich (Terminal UI Framework)

- **Repository**: <https://github.com/Textualize/rich>
- **Purpose**: Advanced terminal UI components and live display management
- **Key Features**:
  - Live display updates with `Live` context manager
  - Layout system with panels and columns
  - Status indicators and progress bars
  - Color and style management
  - Console logging and output control

## Data Source

### HWInfo Sensors CSV Format

- **File**: `ai-docs/sensors.csv` (generated by HWInfo)
- **Structure**: Time-series data with timestamp columns (Date, Time) followed by sensor readings
- **Sample Metrics**:
  - **CPU**: Core temperatures, voltages, clock speeds, usage percentages, power consumption
  - **Memory**: Physical/virtual memory usage, load percentages
  - **GPU**: Temperature, clock speeds, memory usage, power draw
  - **Storage**: Drive temperatures, activity rates, health metrics
  - **System**: Package temperatures, power limits, thermal throttling status

### Data Processing Requirements

- **File Monitoring**: Watch for new lines appended to CSV file
- **Parsing**: Read CSV headers dynamically and parse sensor values
- **Time Handling**: Process Date/Time columns for temporal visualization
- **Data Validation**: Handle missing values, malformed data, and sensor disconnections
- **Performance**: Efficient processing for real-time updates without lag

## User Interface Specification

### gping-inspired Layout

#### Statistics Table (Top Section)

- **Rich Table** displaying real-time sensor statistics similar to gping's ping statistics
- **Columns**:
  - **Sensor Name**: Color-coded sensor identifier
  - **Last**: Most recent sensor value
  - **Min**: Minimum value in current window
  - **Max**: Maximum value in current window  
  - **Avg**: Average value in current window
  - **P95**: 95th percentile value
  - **Unit**: Sensor unit (°C, %, W, MHz, etc.)
- **Color Coding**: Green/Yellow/Red based on configurable thresholds
- **Live Updates**: Values update in real-time as new data arrives

#### Main Chart Area (Bottom Section)

- **Single Line Chart**: All selected sensors plotted on one chart using plotext
- **Multiple Y-Axes**: Left and right y-axes for different sensor scales/units
- **Time-based X-Axis**: Horizontal time axis showing recent history
- **Sensor Lines**: Each sensor represented by different colored line with unique markers
- **Legend**: Sensor names with their corresponding colors
- **Responsive Sizing**: Chart adapts to terminal dimensions

### Interactive Features

#### Navigation Controls

- **Q/Ctrl+C**: Quit application (similar to gping)
- **Space**: Pause/resume real-time updates
- **R**: Reset chart view and statistics
- **Ctrl+L**: Clear screen and reset

#### Display Options

- **+/-**: Zoom in/out on time window
- **←/→**: Pan through historical data when paused
- **T**: Toggle time format (relative/absolute)
- **C**: Cycle through color themes

#### Real-time Behavior

- **Continuous Updates**: Chart scrolls left as new data arrives
- **Automatic Scaling**: Y-axes adjust to data ranges
- **Smooth Animation**: Similar to gping's smooth line drawing
- **Data Retention**: Configurable history window (default: 5 minutes)

## Implementation Requirements

### Core Functionality

#### Command-line Argument Processing

```
- Parse CSV file path and validate existence
- Parse sensor names with fuzzy matching support
- Validate sensor names exist in CSV headers
- Handle partial sensor name matching with suggestions
- Display available sensors if invalid names provided
```

#### Data Processing Engine

```
- CSV file monitoring with efficient tail-following
- Real-time data parsing for selected sensors only
- Time-based data windowing and statistics calculation
- Memory-efficient circular buffers for each selected sensor
- Automatic handling of missing data points
```

#### Statistics Calculator

```
- Real-time calculation of last/min/max/avg/p95 values
- Rolling window statistics over configurable time period
- Efficient percentile calculation for large datasets
- Unit detection and formatting from sensor names
- Threshold-based color coding for statistics table
```

#### Visualization Engine

```
- Single chart generation using plotext with multiple y-axes
- Smooth real-time updates using plotext's streaming functions
- Automatic y-axis scaling for different sensor units
- Color-coded sensor lines with distinct markers
- Responsive chart sizing based on terminal dimensions
- Rich table rendering above chart for statistics display
```

### Performance Requirements

#### System Resources

- **Memory Usage**: < 50MB baseline, < 100MB with full data retention
- **CPU Overhead**: < 2% of single core during normal operation
- **Disk I/O**: Minimal, only for configuration and log files
- **Startup Time**: < 2 seconds from launch to first display

#### Data Handling

- **Update Frequency**: 1-2 second refresh cycles
- **Data Retention**: Configurable (default: 1 hour of history)
- **Chart Responsiveness**: < 100ms for display updates
- **File Monitoring**: Near real-time detection of new CSV data

### Configuration System

#### Settings File (config.toml)

```toml
[display]
refresh_rate = 1.0  # seconds
theme = "default"   # default/dark/high-contrast
time_window = 300   # seconds of history to display

[sensors]
cpu_temp_critical = 85    # Celsius
gpu_temp_warning = 75     # Celsius
memory_usage_warning = 80 # Percentage

[charts]
default_type = "line"     # line/scatter/bar
smooth_updates = true
auto_scale = true
```

#### Alert Configuration

- **Temperature Thresholds**: Configurable warning/critical levels
- **Usage Alerts**: Memory, CPU, and storage utilization warnings
- **Visual Indicators**: Color changes, blinking, status messages
- **Audio Alerts**: Optional system beeps for critical conditions

### Error Handling

#### Graceful Degradation

- **Missing Sensors**: Continue operation with available data
- **File Access Issues**: Display warning and retry mechanism
- **Corrupted Data**: Skip invalid entries and log errors
- **Terminal Issues**: Fallback to basic display modes

#### Recovery Mechanisms

- **Auto-reconnect**: Automatic retry for lost data sources
- **Safe Mode**: Minimal display when full UI fails
- **Error Logging**: Detailed logs for troubleshooting
- **User Feedback**: Clear error messages and suggested actions

## Implementation Requirements

### Command-line Interface Requirements

- **Framework**: Use Typer for command-line argument parsing and validation
- Accept CSV file path as first positional argument with Path type validation
- Accept one or more sensor names as variadic positional arguments
- Support optional flags for refresh rate (float), time window (integer), and theme (string)
- Leverage Typer's type hints for automatic validation and conversion
- Provide rich help messages with examples using Typer's help formatting
- Enable shell auto-completion for improved user experience
- Display helpful error messages for invalid sensors, missing files, or invalid arguments

### Statistics Table Requirements

- Display above the chart in a compact table format
- Show columns: Sensor, Last, Min, Max, Avg, P95
- **Only include sensors that passed unit filtering** in the statistics table
- Use color coding to highlight critical values
- Right-align numeric values for better readability
- Support dynamic resizing based on terminal width
- Group sensors by unit if two units are present (visual separation)

### Chart Display Requirements

- Single line chart displaying all selected sensors that match unit criteria
- **Unit Filtering**: Only display sensors with the first two unique units encountered
- Use dual y-axes when sensors have two different units (left and right axes)
- Use single y-axis when all sensors share the same unit
- Automatically assign colors to differentiate sensors
- Scale chart to use remaining terminal space below statistics table
- Update in real-time without flickering
- Include time labels on x-axis and appropriate unit labels on y-axes
- Display warning messages for sensors excluded due to unit limitations

### Data Processing Requirements

- Monitor CSV file for new data additions
- Parse sensor columns by exact name matching
- **Unit Detection**: Extract units from sensor names (e.g., "[°C]", "[%]", "[MHz]")
- **Unit-based Filtering**: Accept only sensors matching the first two unique units found
- Display informational messages about excluded sensors and their units
- Maintain rolling window of historical data
- Calculate statistics efficiently for real-time updates
- Handle missing or malformed data gracefully

### Unit Management Logic

- Process sensors in the order they appear in command arguments
- Identify unit from sensor name (typically in brackets like "[°C]", "[%]", "[rpm]")
- Accept the first sensor regardless of unit
- Accept subsequent sensors only if their unit matches the first unit OR is a new second unit
- Once two different units are established, reject any sensors with different units
- Provide clear feedback about which sensors were included/excluded and why
- Log excluded sensors with format: "Excluded sensor 'X' with unit [Y] - chart limited to units [A] and [B]"

## Python CLI Development Best Practices

### Project Structure and Packaging

#### Recommended Directory Structure

```
hwinfo-tui/
├── src/
│   └── hwinfo_tui/
│       ├── __init__.py
│       ├── main.py              # Entry point and CLI setup
│       ├── cli.py               # Typer command definitions
│       ├── data/
│       │   ├── __init__.py
│       │   ├── csv_reader.py    # CSV parsing and monitoring
│       │   └── sensors.py       # Sensor data models
│       ├── display/
│       │   ├── __init__.py
│       │   ├── chart.py         # Plotext chart generation
│       │   ├── table.py         # Rich statistics table
│       │   └── layout.py        # UI layout management
│       └── utils/
│           ├── __init__.py
│           ├── stats.py         # Statistics calculations
│           └── units.py         # Unit detection and filtering
├── tests/
│   ├── __init__.py
│   ├── test_cli.py
│   ├── test_data/
│   └── test_display/
├── pyproject.toml               # Modern Python packaging
├── README.md
├── CHANGELOG.md
└── .gitignore
```

#### Packaging Configuration (pyproject.toml)

- Use modern `pyproject.toml` instead of `setup.py`
- Define entry points for CLI commands
- Specify dependencies with version constraints
- Include development dependencies for testing and linting
- Configure build system (setuptools, poetry, or hatch)

### Code Organization and Architecture

#### Separation of Concerns

- **CLI Layer**: Handle argument parsing, validation, and user interaction
- **Data Layer**: CSV reading, parsing, and sensor data management
- **Display Layer**: Chart generation, table formatting, and UI updates
- **Business Logic**: Statistics calculation, unit filtering, and data processing

#### Error Handling Strategy

- **Input Validation**: Validate file paths, sensor names, and argument ranges at CLI level
- **Graceful Degradation**: Handle missing sensors, file access issues, and malformed data
- **User-Friendly Messages**: Provide clear, actionable error messages with suggestions
- **Logging**: Implement structured logging for debugging and troubleshooting
- **Exit Codes**: Use standard exit codes (0=success, 1=error, 2=invalid usage)

#### Configuration Management

- **Environment Variables**: Support configuration via environment variables
- **Config Files**: Optional configuration file support (TOML/YAML)
- **XDG Base Directory**: Follow XDG standards for config file placement on Linux
- **Defaults**: Sensible defaults that work out of the box

### Performance and Resource Management

#### Memory Efficiency

- **Circular Buffers**: Use fixed-size buffers for historical data to prevent memory growth
- **Lazy Loading**: Load and process data incrementally
- **Generator Patterns**: Use generators for large data processing
- **Resource Cleanup**: Proper cleanup of file handles and resources

#### Responsive UI Updates

- **Async I/O**: Consider asyncio for non-blocking file monitoring
- **Update Throttling**: Limit update frequency to maintain responsiveness
- **Efficient Redrawing**: Only update changed portions of the display

### Testing and Quality Assurance

#### Testing Strategy

- **Unit Tests**: Test individual functions and classes in isolation
- **Integration Tests**: Test component interactions and data flow
- **CLI Testing**: Use Typer's testing utilities for command-line interface tests
- **Mock External Dependencies**: Mock file I/O and system dependencies
- **Property-Based Testing**: Use hypothesis for edge case discovery

#### Code Quality Tools

- **Linting**: Use ruff or flake8 for code style and error checking
- **Type Checking**: Use mypy for static type analysis
- **Formatting**: Use black or ruff format for consistent code formatting
- **Security**: Use bandit for security vulnerability scanning
- **Dependency Scanning**: Use safety or pip-audit for vulnerability checks

### Documentation and User Experience

#### Documentation Requirements

- **README**: Clear installation, usage, and examples
- **CLI Help**: Rich help messages with examples using Typer
- **API Documentation**: Docstrings for all public functions and classes
- **Changelog**: Document version changes and breaking changes
- **Contributing Guide**: Guidelines for contributors

#### User Experience Enhancements

- **Progress Indicators**: Show loading states for long operations
- **Autocomplete**: Shell completion for commands and options
- **Interactive Features**: Consider rich prompts for configuration
- **Keyboard Shortcuts**: Standard shortcuts (Ctrl+C, q for quit)
- **Responsive Design**: Adapt to different terminal sizes

### Distribution and Installation

#### Distribution Strategy

- **PyPI Publishing**: Package for easy `pip install` distribution
- **GitHub Releases**: Tagged releases with binaries if needed
- **Container Images**: Docker images for isolated execution
- **Package Managers**: Consider conda-forge or OS package managers

#### Installation Considerations

- **Python Version Support**: Target Python 3.8+ for broad compatibility
- **Dependency Management**: Minimize dependencies and pin versions carefully
- **Virtual Environment**: Recommend virtual environment usage
- **System Integration**: Consider system service capabilities for monitoring

### Security and Reliability

#### Security Best Practices

- **Input Sanitization**: Validate and sanitize all user inputs
- **File Path Validation**: Prevent directory traversal attacks
- **Dependency Security**: Regular dependency updates and vulnerability scanning
- **Least Privilege**: Run with minimal required permissions

#### Reliability Features

- **Graceful Shutdown**: Handle interruption signals properly
- **Recovery Mechanisms**: Restart monitoring after temporary failures
- **Data Validation**: Validate CSV data format and content
- **Resource Limits**: Implement reasonable limits on memory and CPU usage

-----

This specification provides the foundation for building a professional-grade hardware monitoring tool that combines the power of modern terminal UI frameworks with real-time data visualization capabilities.
